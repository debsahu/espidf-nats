/**
 * NATS Client Comprehensive Feature Test
 *
 * Tests all features of the ESP-IDF NATS client library:
 * - Basic pub/sub
 * - Request/Reply
 * - Headers (HPUB/HMSG)
 * - JetStream (streams, consumers, pull, ACK)
 * - Key-Value Store
 * - Object Store
 * - Ordered Consumers
 * - Fetch Operations
 * - Direct Get
 * - Consumer Pause
 * - Account Info
 * - Connection Metrics
 * - WebSocket Transport (ws:// and wss://)
 */

#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/event_groups.h"
#include "esp_system.h"
#include "esp_wifi.h"
#include "esp_event.h"
#include "esp_log.h"
#include "nvs_flash.h"
#include "espidf_nats.h"

static const char* TAG = "nats_test";

// WiFi configuration - UPDATE THESE
#define WIFI_SSID      "YOUR_WIFI_SSID"
#define WIFI_PASS      "YOUR_WIFI_PASSWORD"

// NATS server configuration - UPDATE THESE
#define NATS_SERVER    "YOUR_NATS_SERVER_IP"  // e.g., "192.168.1.100" or "demo.nats.io"
#define NATS_PORT      4223                    // JetStream port (from docker-compose)

// TLS Configuration
#define NATS_USE_TLS   0                // Set to 1 to enable TLS
#define NATS_TLS_PORT  4224             // TLS port (from docker-compose)

#if NATS_USE_TLS
// CA certificate - paste contents of docker/certs/ca-cert.pem here
// Generated by: make certs-gen (or docker compose up generate-certs)
// Before using TLS:
// 1. Run 'make certs-gen' to generate certificates
// 2. Add your server IP to docker/scripts/generate-certs.sh in [alt_names]
// 3. Copy the contents of docker/certs/ca-cert.pem here
static const char ca_cert[] =
"-----BEGIN CERTIFICATE-----\n"
"YOUR_CA_CERTIFICATE_HERE\n"
"-----END CERTIFICATE-----\n";
#endif

// Test control - Enable tests as needed
#define RUN_BASIC_TESTS        1   // Basic pub/sub, request/reply, headers
#define RUN_JETSTREAM_TESTS    1   // JetStream streams, consumers, pull
#define RUN_KV_TESTS           1   // Key-Value store (requires JetStream)
#define RUN_OBJECT_TESTS       1   // Object store (requires JetStream)
#define RUN_ADVANCED_TESTS     1   // Ordered consumers, account info, metrics, reconnection

// WebSocket Tests - Set to 1 and update WEBSOCKET_SERVER_IP to test
// Requires: esp_websocket_client component (add to idf_component.yml)
#define RUN_WEBSOCKET_TESTS      0   // ws:// on port 9222
#define RUN_WEBSOCKET_TLS_TESTS  0   // wss:// on port 9223

// WebSocket server configuration (update to your server IP)
#define WEBSOCKET_SERVER_IP    "YOUR_NATS_SERVER_IP"  // e.g., "192.168.1.100"
#define WEBSOCKET_PORT         9222  // ws:// port (from docker-compose)
#define WEBSOCKET_TLS_PORT     9223  // wss:// port (from docker-compose)

#if RUN_WEBSOCKET_TLS_TESTS
// WebSocket TLS CA certificate - from docker/certs/ca-cert.pem
// Generated by: make certs-gen (or docker compose up generate-certs)
// Copy the contents of docker/certs/ca-cert.pem here
static const char ws_ca_cert[] =
"-----BEGIN CERTIFICATE-----\n"
"YOUR_CA_CERTIFICATE_HERE\n"
"-----END CERTIFICATE-----\n";
#endif

// WiFi event group
static EventGroupHandle_t wifi_event_group;
const int WIFI_CONNECTED_BIT = BIT0;

// Global NATS client
static NATS* nats = NULL;

// Test tracking
static int test_passed = 0;
static int test_failed = 0;

#define TEST_START(name) ESP_LOGI(TAG, "\n========== TEST: %s ==========", name)
#define TEST_PASS(name) do { test_passed++; ESP_LOGI(TAG, "âœ… PASS: %s", name); } while(0)
#define TEST_FAIL(name) do { test_failed++; ESP_LOGE(TAG, "âŒ FAIL: %s", name); } while(0)

/**
 * WiFi event handler
 */
static void wifi_event_handler(void* arg, esp_event_base_t event_base,
                                int32_t event_id, void* event_data)
{
    if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_START) {
        esp_wifi_connect();
    } else if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_DISCONNECTED) {
        ESP_LOGI(TAG, "WiFi disconnected, retrying...");
        esp_wifi_connect();
        xEventGroupClearBits(wifi_event_group, WIFI_CONNECTED_BIT);
    } else if (event_base == IP_EVENT && event_id == IP_EVENT_STA_GOT_IP) {
        ip_event_got_ip_t* event = (ip_event_got_ip_t*) event_data;
        ESP_LOGI(TAG, "WiFi connected, IP: " IPSTR, IP2STR(&event->ip_info.ip));
        xEventGroupSetBits(wifi_event_group, WIFI_CONNECTED_BIT);
    }
}

/**
 * Initialize WiFi in station mode
 */
static void wifi_init_sta(void)
{
    wifi_event_group = xEventGroupCreate();

    ESP_ERROR_CHECK(esp_netif_init());
    ESP_ERROR_CHECK(esp_event_loop_create_default());
    esp_netif_create_default_wifi_sta();

    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&cfg));

    ESP_ERROR_CHECK(esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &wifi_event_handler, NULL));
    ESP_ERROR_CHECK(esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &wifi_event_handler, NULL));

    wifi_config_t wifi_config = {};
    strcpy((char*)wifi_config.sta.ssid, WIFI_SSID);
    strcpy((char*)wifi_config.sta.password, WIFI_PASS);
    wifi_config.sta.threshold.authmode = WIFI_AUTH_WPA2_PSK;

    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));
    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &wifi_config));
    ESP_ERROR_CHECK(esp_wifi_start());

    ESP_LOGI(TAG, "WiFi initialization completed");
}

// ============================================================================
// BASIC TESTS
// ============================================================================

static volatile bool pubsub_received = false;
static void test_pubsub_callback(NATS::msg msg) {
    ESP_LOGI(TAG, "Received: %.*s", msg.size, msg.data);
    pubsub_received = true;
}

static void test_basic_pubsub() {
    TEST_START("Basic Pub/Sub");

    pubsub_received = false;
    nats->subscribe("test.basic", test_pubsub_callback);
    vTaskDelay(pdMS_TO_TICKS(100));

    nats->publish("test.basic", "Hello NATS!");

    // Wait for message
    for (int i = 0; i < 50; i++) {
        nats->process();
        if (pubsub_received) break;
        vTaskDelay(pdMS_TO_TICKS(100));
    }

    if (pubsub_received) {
        TEST_PASS("Basic Pub/Sub");
    } else {
        TEST_FAIL("Basic Pub/Sub - no message received");
    }
}

static volatile bool request_replied = false;
static void test_request_callback(NATS::msg msg) {
    ESP_LOGI(TAG, "Request response: %.*s", msg.size, msg.data);
    request_replied = true;
}

static void test_request_reply() {
    TEST_START("Request/Reply");

    // Setup responder
    nats->subscribe("test.echo", [](NATS::msg msg) {
        ESP_LOGI(TAG, "Echo request: %.*s", msg.size, msg.data);
        nats->publish(msg.reply, msg.data);
    });
    vTaskDelay(pdMS_TO_TICKS(100));

    // Send request
    request_replied = false;
    nats->request("test.echo", "ping", test_request_callback);

    // Wait for response
    for (int i = 0; i < 50; i++) {
        nats->process();
        if (request_replied) break;
        vTaskDelay(pdMS_TO_TICKS(100));
    }

    if (request_replied) {
        TEST_PASS("Request/Reply");
    } else {
        TEST_FAIL("Request/Reply - no response");
    }
}

static volatile bool headers_received = false;
static void test_headers() {
    TEST_START("Headers (HPUB/HMSG)");

    // Subscribe and check for headers
    nats->subscribe("test.headers", [](NATS::msg msg) {
        ESP_LOGI(TAG, "Received with headers - data: %.*s", msg.size, msg.data);
        if (msg.headers != NULL && msg.header_size > 0) {
            ESP_LOGI(TAG, "Headers: %.*s", msg.header_size, msg.headers);
            headers_received = true;
        }
    });
    vTaskDelay(pdMS_TO_TICKS(100));

    // Publish with headers
    const char* headers = "NATS/1.0\r\nX-Test: true\r\n\r\n";
    nats->publish_with_headers("test.headers", headers, "test payload");

    // Wait for message
    for (int i = 0; i < 50; i++) {
        nats->process();
        if (headers_received) break;
        vTaskDelay(pdMS_TO_TICKS(100));
    }

    if (headers_received) {
        TEST_PASS("Headers");
    } else {
        TEST_FAIL("Headers - not received");
    }
}

// ============================================================================
// JETSTREAM TESTS
// ============================================================================

static volatile bool stream_created = false;
static void test_jetstream_stream() {
    TEST_START("JetStream Stream Create");

    const char* subjects[] = {"test.js.>", NULL};
    jetstream_stream_config_t config = {
        .name = "TEST_STREAM",
        .subjects = subjects,
        .max_msgs = 1000,
        .max_bytes = 1048576,
        .max_age = 3600000000000LL,  // 1 hour
        .max_msg_size = 1024,
        .storage = "memory",
        .replicas = 1,
        .discard_new = false
    };

    stream_created = false;
    nats->jetstream_stream_create(&config,
        [](NATS::msg msg) {
            ESP_LOGI(TAG, "Stream response: %.*s", msg.size, msg.data);
            stream_created = true;
        },
        []() { ESP_LOGW(TAG, "Stream create timeout"); },
        5000
    );

    for (int i = 0; i < 100; i++) {
        nats->process();
        if (stream_created) break;
        vTaskDelay(pdMS_TO_TICKS(50));
    }

    if (stream_created) {
        TEST_PASS("JetStream Stream Create");
    } else {
        TEST_FAIL("JetStream Stream Create");
    }
}

static volatile bool js_published = false;
static void test_jetstream_publish() {
    TEST_START("JetStream Publish with ACK");

    js_published = false;
    nats->jetstream_publish("test.js.msg1", "{\"test\":true}",
        [](NATS::msg msg) {
            ESP_LOGI(TAG, "JetStream ACK: %.*s", msg.size, msg.data);
            js_published = true;
        },
        []() { ESP_LOGW(TAG, "Publish timeout"); },
        5000,
        "msg-dedup-1"  // Message ID for deduplication
    );

    for (int i = 0; i < 100; i++) {
        nats->process();
        if (js_published) break;
        vTaskDelay(pdMS_TO_TICKS(50));
    }

    if (js_published) {
        TEST_PASS("JetStream Publish");
    } else {
        TEST_FAIL("JetStream Publish");
    }
}

static volatile bool consumer_created = false;
static void test_jetstream_consumer() {
    TEST_START("JetStream Consumer Create");

    jetstream_consumer_config_t config = {
        .stream_name = "TEST_STREAM",
        .durable_name = "test_consumer",
        .filter_subject = "test.js.>",
        .deliver_all = true,
        .ack_policy = "explicit",
        .ack_wait = 30000000000LL,  // 30 seconds
        .max_deliver = 3,
        .replay_policy = "instant",
        .ordered = false
    };

    consumer_created = false;
    nats->jetstream_consumer_create(&config,
        [](NATS::msg msg) {
            ESP_LOGI(TAG, "Consumer response: %.*s", msg.size, msg.data);
            consumer_created = true;
        },
        []() { ESP_LOGW(TAG, "Consumer create timeout"); },
        5000
    );

    for (int i = 0; i < 100; i++) {
        nats->process();
        if (consumer_created) break;
        vTaskDelay(pdMS_TO_TICKS(50));
    }

    if (consumer_created) {
        TEST_PASS("JetStream Consumer Create");
    } else {
        TEST_FAIL("JetStream Consumer Create");
    }
}

static volatile int messages_pulled = 0;
static void test_jetstream_pull() {
    TEST_START("JetStream Pull");

    messages_pulled = 0;
    nats->jetstream_pull("TEST_STREAM", "test_consumer", 10,
        [](NATS::msg msg) {
            ESP_LOGI(TAG, "Pulled message: %.*s", msg.size, msg.data);
            messages_pulled = messages_pulled + 1;  // Avoid deprecated volatile++
            nats->jetstream_ack(msg.reply);  // Acknowledge
        },
        []() { ESP_LOGW(TAG, "Pull timeout (expected if no messages)"); },
        5000
    );

    for (int i = 0; i < 100; i++) {
        nats->process();
        vTaskDelay(pdMS_TO_TICKS(50));
    }

    if (messages_pulled > 0) {
        TEST_PASS("JetStream Pull");
    } else {
        ESP_LOGW(TAG, "âš ï¸  JetStream Pull - no messages (may be expected)");
    }
}

// ============================================================================
// KEY-VALUE STORE TESTS
// ============================================================================

static volatile bool kv_created = false;
static void test_kv_create() {
    TEST_START("KV Bucket Create");

    kv_config_t config = {
        .bucket = "test_config",
        .description = "Test configuration bucket",
        .max_value_size = 1024,
        .history = 5,
        .ttl = 0,
        .storage = "memory",
        .replicas = 1,
        .max_bytes = 1048576
    };

    kv_created = false;
    nats->kv_create_bucket(&config,
        [](NATS::msg msg) {
            ESP_LOGI(TAG, "KV bucket response: %.*s", msg.size, msg.data);
            kv_created = true;
        },
        []() { ESP_LOGW(TAG, "KV create timeout"); },
        5000
    );

    for (int i = 0; i < 100; i++) {
        nats->process();
        if (kv_created) break;
        vTaskDelay(pdMS_TO_TICKS(50));
    }

    if (kv_created) {
        TEST_PASS("KV Bucket Create");
    } else {
        TEST_FAIL("KV Bucket Create");
    }
}

static volatile bool kv_put_done = false;
static void test_kv_put() {
    TEST_START("KV Put");

    kv_put_done = false;
    nats->kv_put("test_config", "device_id", "ESP32-001",
        [](NATS::msg msg) {
            ESP_LOGI(TAG, "KV put ACK: %.*s", msg.size, msg.data);
            kv_put_done = true;
        },
        []() { ESP_LOGW(TAG, "KV put timeout"); },
        5000
    );

    for (int i = 0; i < 100; i++) {
        nats->process();
        if (kv_put_done) break;
        vTaskDelay(pdMS_TO_TICKS(50));
    }

    if (kv_put_done) {
        TEST_PASS("KV Put");
    } else {
        TEST_FAIL("KV Put");
    }
}

static volatile bool kv_get_done = false;
static void test_kv_get() {
    TEST_START("KV Get");

    kv_get_done = false;
    nats->kv_get("test_config", "device_id",
        [](NATS::msg msg) {
            ESP_LOGI(TAG, "KV get response: %.*s", msg.size, msg.data);
            kv_get_done = true;
        },
        []() { ESP_LOGW(TAG, "KV get timeout"); },
        5000
    );

    for (int i = 0; i < 100; i++) {
        nats->process();
        if (kv_get_done) break;
        vTaskDelay(pdMS_TO_TICKS(50));
    }

    if (kv_get_done) {
        TEST_PASS("KV Get");
    } else {
        TEST_FAIL("KV Get");
    }
}

// ============================================================================
// OBJECT STORE TESTS
// ============================================================================

static volatile bool obj_bucket_created = false;
static void test_obj_create_bucket() {
    TEST_START("Object Store Bucket Create");

    object_store_config_t config = {
        .bucket = "test_firmware",
        .description = "Test firmware bucket",
        .ttl = 0,
        .storage = "memory",
        .replicas = 1,
        .max_bytes = 10485760,  // 10 MB
        .compressed = false
    };

    obj_bucket_created = false;
    nats->obj_create_bucket(&config,
        [](NATS::msg msg) {
            ESP_LOGI(TAG, "Object bucket response: %.*s", msg.size, msg.data);
            obj_bucket_created = true;
        },
        []() { ESP_LOGW(TAG, "Object bucket create timeout"); },
        5000
    );

    for (int i = 0; i < 100; i++) {
        nats->process();
        if (obj_bucket_created) break;
        vTaskDelay(pdMS_TO_TICKS(50));
    }

    if (obj_bucket_created) {
        TEST_PASS("Object Bucket Create");
    } else {
        TEST_FAIL("Object Bucket Create");
    }
}

static volatile bool obj_put_done = false;
static void test_obj_put() {
    TEST_START("Object Store Put");

    // Create test data (250 KB to test chunking)
    const size_t data_size = 250000;
    uint8_t* test_data = (uint8_t*)malloc(data_size);
    if (test_data == NULL) {
        TEST_FAIL("Object Put - malloc failed");
        return;
    }

    // Fill with test pattern
    for (size_t i = 0; i < data_size; i++) {
        test_data[i] = (uint8_t)(i % 256);
    }

    obj_put_done = false;
    nats->obj_put("test_firmware", "test_file.bin", test_data, data_size,
        "Test firmware file",
        [](NATS::msg msg) {
            ESP_LOGI(TAG, "Object put ACK: %.*s", msg.size, msg.data);
            obj_put_done = true;
        },
        []() { ESP_LOGW(TAG, "Object put timeout"); },
        15000  // 15 second timeout for large upload
    );

    for (int i = 0; i < 300; i++) {
        nats->process();
        if (obj_put_done) break;
        vTaskDelay(pdMS_TO_TICKS(50));
    }

    free(test_data);

    if (obj_put_done) {
        TEST_PASS("Object Put (250 KB with chunking)");
    } else {
        TEST_FAIL("Object Put");
    }
}

static volatile bool obj_info_done = false;
static void test_obj_get_info() {
    TEST_START("Object Store Get Info");

    obj_info_done = false;
    nats->obj_get_info("test_firmware", "test_file.bin",
        [](NATS::msg msg) {
            ESP_LOGI(TAG, "Object info: %.*s", msg.size, msg.data);
            obj_info_done = true;
        },
        []() { ESP_LOGW(TAG, "Object info timeout"); },
        5000
    );

    for (int i = 0; i < 100; i++) {
        nats->process();
        if (obj_info_done) break;
        vTaskDelay(pdMS_TO_TICKS(50));
    }

    if (obj_info_done) {
        TEST_PASS("Object Get Info");
    } else {
        TEST_FAIL("Object Get Info");
    }
}

// ============================================================================
// ADVANCED TESTS
// ============================================================================

static volatile bool ordered_created = false;
static void test_ordered_consumer() {
    TEST_START("Ordered Consumer");

    ordered_created = false;
    nats->jetstream_consumer_create_ordered("TEST_STREAM", "test.js.>",
        [](NATS::msg msg) {
            ESP_LOGI(TAG, "Ordered consumer response: %.*s", msg.size, msg.data);
            ordered_created = true;
        },
        []() { ESP_LOGW(TAG, "Ordered consumer timeout"); },
        5000
    );

    for (int i = 0; i < 100; i++) {
        nats->process();
        if (ordered_created) break;
        vTaskDelay(pdMS_TO_TICKS(50));
    }

    if (ordered_created) {
        TEST_PASS("Ordered Consumer");
    } else {
        TEST_FAIL("Ordered Consumer");
    }
}

static volatile bool account_info_received = false;
static void test_account_info() {
    TEST_START("JetStream Account Info");

    account_info_received = false;
    nats->jetstream_account_info(
        [](NATS::msg msg) {
            ESP_LOGI(TAG, "Account info: %.*s", msg.size, msg.data);
            account_info_received = true;
        },
        []() { ESP_LOGW(TAG, "Account info timeout"); },
        5000
    );

    for (int i = 0; i < 100; i++) {
        nats->process();
        if (account_info_received) break;
        vTaskDelay(pdMS_TO_TICKS(50));
    }

    if (account_info_received) {
        TEST_PASS("Account Info");
    } else {
        TEST_FAIL("Account Info");
    }
}

static void test_connection_metrics() {
    TEST_START("Connection Metrics");

    nats_connection_metrics_t metrics = nats->get_metrics();

    ESP_LOGI(TAG, "Connection Metrics:");
    ESP_LOGI(TAG, "  Messages sent: %llu", metrics.msgs_sent);
    ESP_LOGI(TAG, "  Messages received: %llu", metrics.msgs_received);
    ESP_LOGI(TAG, "  Bytes sent: %llu", metrics.bytes_sent);
    ESP_LOGI(TAG, "  Bytes received: %llu", metrics.bytes_received);
    ESP_LOGI(TAG, "  Reconnections: %u", metrics.reconnections);
    ESP_LOGI(TAG, "  Uptime: %lu ms", metrics.uptime);

    if (metrics.msgs_sent > 0 && metrics.msgs_received > 0) {
        TEST_PASS("Connection Metrics");
    } else {
        TEST_FAIL("Connection Metrics - no traffic");
    }
}

// Test reconnection with subscription restoration
static volatile bool reconnect_msg_received = false;
static void test_reconnection() {
    TEST_START("Reconnection with Subscription Restoration");

    // Subscribe BEFORE disconnect
    reconnect_msg_received = false;
    int sid = nats->subscribe("test.reconnect", [](NATS::msg msg) {
        ESP_LOGI(TAG, "Reconnect test msg: %.*s", msg.size, msg.data);
        reconnect_msg_received = true;
    });

    if (sid < 0) {
        TEST_FAIL("Reconnection - failed to subscribe");
        return;
    }
    ESP_LOGI(TAG, "Subscribed to test.reconnect (sid=%d)", sid);
    vTaskDelay(pdMS_TO_TICKS(100));

    // Force disconnect
    ESP_LOGI(TAG, "Forcing disconnect...");
    nats->disconnect();
    vTaskDelay(pdMS_TO_TICKS(500));

    // Reconnect
    ESP_LOGI(TAG, "Reconnecting...");
    if (!nats->connect()) {
        TEST_FAIL("Reconnection - failed to reconnect");
        return;
    }

    // Wait for connection to establish
    for (int i = 0; i < 100; i++) {
        nats->process();
        if (nats->connected) break;
        vTaskDelay(pdMS_TO_TICKS(50));
    }

    if (!nats->connected) {
        TEST_FAIL("Reconnection - not connected after reconnect");
        return;
    }
    ESP_LOGI(TAG, "Reconnected! Subscriptions should be restored.");
    vTaskDelay(pdMS_TO_TICKS(500));

    // Publish to the subscription (should work if restored)
    nats->publish("test.reconnect", "Hello after reconnect!");

    // Wait for message
    for (int i = 0; i < 50; i++) {
        nats->process();
        if (reconnect_msg_received) break;
        vTaskDelay(pdMS_TO_TICKS(100));
    }

    if (reconnect_msg_received) {
        TEST_PASS("Reconnection with Subscription Restoration");
    } else {
        TEST_FAIL("Reconnection - subscription not restored");
    }

    // Cleanup
    nats->unsubscribe(sid);
}

// ============================================================================
// WEBSOCKET TRANSPORT TESTS
// ============================================================================

#if (RUN_WEBSOCKET_TESTS || RUN_WEBSOCKET_TLS_TESTS)

static NATS* ws_nats = NULL;
static volatile bool ws_pubsub_received = false;
static volatile bool ws_request_replied = false;
static volatile bool ws_jetstream_ack = false;
static volatile bool ws_stream_ok = false;  // Static for callback (can't use lambda capture)

static void ws_pubsub_callback(NATS::msg msg) {
    ESP_LOGI(TAG, "[WS] Received: %.*s", msg.size, msg.data);
    ws_pubsub_received = true;
}

static void test_websocket_pubsub() {
    TEST_START("WebSocket Basic Pub/Sub");

    ws_pubsub_received = false;
    ws_nats->subscribe("ws.test.basic", ws_pubsub_callback);
    vTaskDelay(pdMS_TO_TICKS(100));

    ws_nats->publish("ws.test.basic", "Hello WebSocket NATS!");

    for (int i = 0; i < 50; i++) {
        ws_nats->process();
        if (ws_pubsub_received) break;
        vTaskDelay(pdMS_TO_TICKS(100));
    }

    if (ws_pubsub_received) {
        TEST_PASS("WebSocket Basic Pub/Sub");
    } else {
        TEST_FAIL("WebSocket Basic Pub/Sub - no message received");
    }
}

static void test_websocket_request_reply() {
    TEST_START("WebSocket Request/Reply");

    // Setup responder
    ws_nats->subscribe("ws.test.echo", [](NATS::msg msg) {
        ESP_LOGI(TAG, "[WS] Echo request: %.*s", msg.size, msg.data);
        ws_nats->publish(msg.reply, msg.data);
    });
    vTaskDelay(pdMS_TO_TICKS(100));

    // Send request
    ws_request_replied = false;
    ws_nats->request("ws.test.echo", "WS ping", [](NATS::msg msg) {
        ESP_LOGI(TAG, "[WS] Request response: %.*s", msg.size, msg.data);
        ws_request_replied = true;
    });

    for (int i = 0; i < 50; i++) {
        ws_nats->process();
        if (ws_request_replied) break;
        vTaskDelay(pdMS_TO_TICKS(100));
    }

    if (ws_request_replied) {
        TEST_PASS("WebSocket Request/Reply");
    } else {
        TEST_FAIL("WebSocket Request/Reply - no response");
    }
}

static void test_websocket_jetstream() {
    TEST_START("WebSocket JetStream Publish");

    // Create stream for WebSocket tests
    const char* subjects[] = {"ws.js.>", NULL};
    jetstream_stream_config_t config = {
        .name = "WS_TEST_STREAM",
        .subjects = subjects,
        .max_msgs = 100,
        .max_bytes = 1048576,
        .max_age = 3600000000000LL,
        .max_msg_size = 1024,
        .storage = "memory",
        .replicas = 1,
        .discard_new = false
    };

    ws_stream_ok = false;
    ws_nats->jetstream_stream_create(&config,
        [](NATS::msg msg) {
            ESP_LOGI(TAG, "[WS] Stream response: %.*s", msg.size, msg.data);
            ws_stream_ok = true;
        },
        []() { ESP_LOGW(TAG, "[WS] Stream create timeout"); },
        5000
    );

    for (int i = 0; i < 100; i++) {
        ws_nats->process();
        if (ws_stream_ok) break;
        vTaskDelay(pdMS_TO_TICKS(50));
    }

    if (!ws_stream_ok) {
        ESP_LOGW(TAG, "WebSocket JetStream Stream Create failed (may already exist)");
    }

    // Publish with ACK
    ws_jetstream_ack = false;
    ws_nats->jetstream_publish("ws.js.test", "{\"websocket\":true}",
        [](NATS::msg msg) {
            ESP_LOGI(TAG, "[WS] JetStream ACK: %.*s", msg.size, msg.data);
            ws_jetstream_ack = true;
        },
        []() { ESP_LOGW(TAG, "[WS] Publish timeout"); },
        5000,
        "ws-msg-1"
    );

    for (int i = 0; i < 100; i++) {
        ws_nats->process();
        if (ws_jetstream_ack) break;
        vTaskDelay(pdMS_TO_TICKS(50));
    }

    if (ws_jetstream_ack) {
        TEST_PASS("WebSocket JetStream Publish");
    } else {
        TEST_FAIL("WebSocket JetStream Publish");
    }
}

static void test_websocket_metrics() {
    TEST_START("WebSocket Connection Metrics");

    nats_connection_metrics_t metrics = ws_nats->get_metrics();

    ESP_LOGI(TAG, "[WS] Connection Metrics:");
    ESP_LOGI(TAG, "  Messages sent: %llu", metrics.msgs_sent);
    ESP_LOGI(TAG, "  Messages received: %llu", metrics.msgs_received);
    ESP_LOGI(TAG, "  Bytes sent: %llu", metrics.bytes_sent);
    ESP_LOGI(TAG, "  Bytes received: %llu", metrics.bytes_received);
    ESP_LOGI(TAG, "  Reconnections: %u", metrics.reconnections);
    ESP_LOGI(TAG, "  Uptime: %lu ms", metrics.uptime);

    if (metrics.msgs_sent > 0 && metrics.msgs_received > 0) {
        TEST_PASS("WebSocket Connection Metrics");
    } else {
        TEST_FAIL("WebSocket Connection Metrics - no traffic");
    }
}

static void run_websocket_tests(bool use_tls) {
    const char* mode = use_tls ? "wss://" : "ws://";
    int port = use_tls ? WEBSOCKET_TLS_PORT : WEBSOCKET_PORT;

    ESP_LOGI(TAG, "\n========== WEBSOCKET TRANSPORT TESTS (%s) ==========", mode);

#if RUN_WEBSOCKET_TLS_TESTS
    if (use_tls) {
        // Create WebSocket client with TLS
        nats_tls_config_t tls_config = {};
        tls_config.enabled = true;
        tls_config.ca_cert = ws_ca_cert;
        tls_config.ca_cert_len = sizeof(ws_ca_cert);
        tls_config.skip_cert_verification = false;

        ws_nats = NATS::create_websocket(WEBSOCKET_SERVER_IP, port, NULL, NULL, &tls_config);
    } else
#endif
    {
        // Create WebSocket client without TLS
        ws_nats = NATS::create_websocket(WEBSOCKET_SERVER_IP, port);
    }

    if (ws_nats == NULL) {
        ESP_LOGE(TAG, "Failed to create WebSocket NATS client!");
        TEST_FAIL("WebSocket Client Creation");
        return;
    }

    ws_nats->on_connect = []() { ESP_LOGI(TAG, "[WS] Connected to NATS via WebSocket"); };
    ws_nats->on_disconnect = []() { ESP_LOGW(TAG, "[WS] Disconnected from NATS"); };
    ws_nats->on_error = []() { ESP_LOGE(TAG, "[WS] Error: %s", ws_nats->last_error_string()); };

    // Connect via WebSocket
    ESP_LOGI(TAG, "Connecting to WebSocket NATS server %s %s:%d...", mode, WEBSOCKET_SERVER_IP, port);
    if (!ws_nats->connect()) {
        ESP_LOGE(TAG, "Failed to connect via WebSocket: %s", ws_nats->last_error_string());
        TEST_FAIL("WebSocket Connection");
        delete ws_nats;
        ws_nats = NULL;
        return;
    }

    TEST_PASS("WebSocket Connection");

    // Process connection handshake
    for (int i = 0; i < 100; i++) {
        ws_nats->process();
        vTaskDelay(pdMS_TO_TICKS(10));
    }

    // Run WebSocket tests
    test_websocket_pubsub();
    vTaskDelay(pdMS_TO_TICKS(500));

    test_websocket_request_reply();
    vTaskDelay(pdMS_TO_TICKS(500));

    test_websocket_jetstream();
    vTaskDelay(pdMS_TO_TICKS(500));

    test_websocket_metrics();
    vTaskDelay(pdMS_TO_TICKS(500));

    // Cleanup
    ESP_LOGI(TAG, "Closing WebSocket connection...");
    ws_nats->drain(5000);
    delete ws_nats;
    ws_nats = NULL;

    ESP_LOGI(TAG, "========== WEBSOCKET TESTS COMPLETE ==========\n");
}

#endif // RUN_WEBSOCKET_TESTS || RUN_WEBSOCKET_TLS_TESTS

// ============================================================================
// MAIN TEST TASK
// ============================================================================

static void nats_test_task(void* arg)
{
    // Wait for WiFi
    ESP_LOGI(TAG, "Waiting for WiFi connection...");
    xEventGroupWaitBits(wifi_event_group, WIFI_CONNECTED_BIT, false, true, portMAX_DELAY);

    // Create NATS client
    ESP_LOGI(TAG, "Creating NATS client...");

#if NATS_USE_TLS
    // Configure TLS with embedded CA certificate
    nats_tls_config_t tls_config = {};
    tls_config.enabled = true;
    tls_config.ca_cert = ca_cert;
    tls_config.ca_cert_len = sizeof(ca_cert);
    // Don't set server_name for IP connections - SAN will be checked for IP match
    // tls_config.server_name = NATS_SERVER;

    nats = new NATS(NATS_SERVER, NATS_TLS_PORT, NULL, NULL, &tls_config);
    ESP_LOGI(TAG, "TLS enabled, connecting to port %d", NATS_TLS_PORT);
#else
    nats = new NATS(NATS_SERVER, NATS_PORT);
#endif

    if (nats == NULL) {
        ESP_LOGE(TAG, "Failed to create NATS client!");
        vTaskDelete(NULL);
        return;
    }

    nats->on_connect = []() { ESP_LOGI(TAG, "âœ… Connected to NATS"); };
    nats->on_disconnect = []() { ESP_LOGW(TAG, "âŒ Disconnected from NATS"); };
    nats->on_error = []() { ESP_LOGE(TAG, "âš ï¸  NATS error: %s", nats->last_error_string()); };

    // Connect
    ESP_LOGI(TAG, "Connecting to NATS server %s:%d...", NATS_SERVER, NATS_PORT);
    if (!nats->connect()) {
        ESP_LOGE(TAG, "Failed to connect: %s", nats->last_error_string());
        vTaskDelete(NULL);
        return;
    }

    // Process connection handshake
    for (int i = 0; i < 100; i++) {
        nats->process();
        vTaskDelay(pdMS_TO_TICKS(10));
    }

    ESP_LOGI(TAG, "\n");
    ESP_LOGI(TAG, "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    ESP_LOGI(TAG, "â•‘  ESP-IDF NATS CLIENT - COMPREHENSIVE FEATURE TEST     â•‘");
    ESP_LOGI(TAG, "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    ESP_LOGI(TAG, "\n");

    // Run basic tests
    #if RUN_BASIC_TESTS
    ESP_LOGI(TAG, "========== BASIC FEATURES ==========");
    test_basic_pubsub();
    vTaskDelay(pdMS_TO_TICKS(500));

    test_request_reply();
    vTaskDelay(pdMS_TO_TICKS(500));

    test_headers();
    vTaskDelay(pdMS_TO_TICKS(500));
    #endif

    // Run JetStream tests
    #if RUN_JETSTREAM_TESTS
    ESP_LOGI(TAG, "\n========== JETSTREAM FEATURES ==========");
    test_jetstream_stream();
    vTaskDelay(pdMS_TO_TICKS(500));

    test_jetstream_publish();
    vTaskDelay(pdMS_TO_TICKS(500));

    test_jetstream_consumer();
    vTaskDelay(pdMS_TO_TICKS(500));

    test_jetstream_pull();
    vTaskDelay(pdMS_TO_TICKS(500));
    #endif

    // Run KV tests
    #if RUN_KV_TESTS
    ESP_LOGI(TAG, "\n========== KEY-VALUE STORE ==========");
    test_kv_create();
    vTaskDelay(pdMS_TO_TICKS(500));

    test_kv_put();
    vTaskDelay(pdMS_TO_TICKS(500));

    test_kv_get();
    vTaskDelay(pdMS_TO_TICKS(500));
    #endif

    // Run Object Store tests
    #if RUN_OBJECT_TESTS
    ESP_LOGI(TAG, "\n========== OBJECT STORE ==========");
    test_obj_create_bucket();
    vTaskDelay(pdMS_TO_TICKS(500));

    test_obj_put();
    vTaskDelay(pdMS_TO_TICKS(500));

    test_obj_get_info();
    vTaskDelay(pdMS_TO_TICKS(500));
    #endif

    // Run advanced tests
    #if RUN_ADVANCED_TESTS
    ESP_LOGI(TAG, "\n========== ADVANCED FEATURES ==========");
    test_ordered_consumer();
    vTaskDelay(pdMS_TO_TICKS(500));

    test_account_info();
    vTaskDelay(pdMS_TO_TICKS(500));

    test_connection_metrics();
    vTaskDelay(pdMS_TO_TICKS(500));

    test_reconnection();
    vTaskDelay(pdMS_TO_TICKS(500));
    #endif

    // Run WebSocket tests (uses separate connection)
    #if RUN_WEBSOCKET_TESTS
    run_websocket_tests(false);  // ws://
    vTaskDelay(pdMS_TO_TICKS(1000));
    #endif

    #if RUN_WEBSOCKET_TLS_TESTS
    run_websocket_tests(true);   // wss://
    vTaskDelay(pdMS_TO_TICKS(1000));
    #endif

    // Print summary
    ESP_LOGI(TAG, "\n");
    ESP_LOGI(TAG, "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    ESP_LOGI(TAG, "â•‘                    TEST SUMMARY                        â•‘");
    ESP_LOGI(TAG, "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    ESP_LOGI(TAG, "  âœ… Passed: %d", test_passed);
    ESP_LOGI(TAG, "  âŒ Failed: %d", test_failed);
    ESP_LOGI(TAG, "  Total:  %d", test_passed + test_failed);
    ESP_LOGI(TAG, "\n");

    if (test_failed == 0) {
        ESP_LOGI(TAG, "ðŸŽ‰ ALL TESTS PASSED! ðŸŽ‰");
    } else {
        ESP_LOGW(TAG, "âš ï¸  Some tests failed. Check logs above.");
    }

    // Keep processing
    ESP_LOGI(TAG, "Keeping connection alive. Monitoring metrics every 30s...");
    while (1) {
        nats->process();
        vTaskDelay(pdMS_TO_TICKS(10));

        static int counter = 0;
        if (++counter >= 3000) {  // Every 30 seconds
            counter = 0;
            nats_connection_metrics_t metrics = nats->get_metrics();
            ESP_LOGI(TAG, "Metrics: Msgs %llu/%llu, Bytes %llu/%llu, Uptime %lu ms",
                metrics.msgs_sent, metrics.msgs_received,
                metrics.bytes_sent, metrics.bytes_received,
                metrics.uptime);
        }
    }

    vTaskDelete(NULL);
}

// ============================================================================
// MAIN
// ============================================================================

extern "C" void app_main(void)
{
    ESP_LOGI(TAG, "ESP-IDF NATS Client - Comprehensive Test");
    ESP_LOGI(TAG, "ESP-IDF Version: %s", esp_get_idf_version());

    // Initialize NVS
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);

    // Initialize WiFi
    wifi_init_sta();

    // Create test task
    xTaskCreate(nats_test_task, "nats_test", 8192, NULL, 5, NULL);
}
